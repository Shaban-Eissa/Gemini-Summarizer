[
  {
    "id": "433ddfa3-91db-4820-9847-c47d6acd2d5c",
    "text": "Like it or not, we live in the age of AI, and it can be both exciting and frustrating. On one hand, AI can help us unlock almost unlimited capabilities for the apps we build; if in the past, tasks like image recognition or text classification could be a dealbreaker for the average developer, today, customers almost assume one would be able to pull things like this off in ridiculously short timeframes. On the other hand, however, the landscape of AI development is probably best described as \"hostile\". We move at incredible speeds, new models and approaches drop and then die out before we even have time to properly use them, lots of tutorials are actually disguised ways of selling us something, and lots of information is still being gatekeeped by more seasoned developers, hidden behind buzzwords like \"agentic AI\" , \"RAG\" and so on. This can be particularly harsh if you're a JavaScript developer, especially working on frontend, like me, with Angular. \"Do I need to learn Python to do AI?\", \"I'm not a backend developer, how can I build apps with AI?\", and \"How do I even get started, there's so much stuff out there!\" are all questions I've heard from developers in my community. Well, to be honest, those are questions I've asked myself as well. So, for the past couple of months I've been working with the Gemini API, building different apps and tools, and now is the time I dispel some myths for other Angular developers and help them begin their AI journey too. So, hereby, we begin a series of articles on how to build AI-powered apps with Angular and Gemini. This is going to be a ground-up tutorial, broken down into atomic topics that will help you get started without issue. The good news is, no prior knowledge is assumed! If you are an Angular developer who has no idea how people build apps on top of AI models, this is where you start! In this series, we will cover the following topics: Please do not assume this is going to be just a 7 article series, it is very possible I ",
    "summary": "This article introduces a series on building AI-powered Angular apps using the Gemini API, targeting JavaScript/Angular developers with little to no AI experience. It covers setting up the Gemini API with Angular, including backend setup with Express.js for security, and explores key concepts like API keys, environment variables, and SDK usage. Additionally, it discusses choosing appropriate Gemini models, understanding token-based pricing, and adjusting parameters like temperature, topK, topP, and maxOutputTokens for refined AI responses.",
    "url": "https://www.angularspace.com/building-ai-powered-apps-with-angular-and-gemini/",
    "style": "short",
    "createdAt": "2025-10-14T13:57:24.737Z"
  },
  {
    "id": "1e6ad84c-eabc-403b-a470-890af0c7098b",
    "text": "\n\t\t\t\t\tConnie's Programming Journey\n\t\t\t\t Software architect. Web Development, build apps with Angular, TypeScript, JavaScript, and NestJS   I am an Angular and NestJS developer interested in Angular, Vue, NestJS, and Generate AI. Blog sites such as dev.to and hashnode have many new blog posts daily, and it is difficult for me to pick out the good ones to read and improve my knowledge of web development and generative AI. Therefore, I built a text summarization application to call my NestJS backend to provide a summary of a technology blog post. When the summary sounds interesting, I read the rest of the post. Otherwise, I stop and find other ones to read. The full-stack generative application helps me decide whether to read a technology blog post. The shell component renders a navigation bar for a user to navigate to different text summarization components. The first component provides a paragraph summary, while the second one returns a bullet point summary. When a user visits /summarization-page, the page allows the user to enter a web page URL and provides a paragraph summary. When a user visits /summarization-as-list, the page allows the user to enter a web page URL and get back a bullet point summary. This is a component that accepts a web page URL and an optional topic hint.  When a prompt includes a topic hint, Gemini provides a more accurate summary than without.  WebPageInputContainerComponent emits the web page URL and topic hint to the enclosing summarization component. SummarizeParagraphComponent uses viewchild to access the submitted URL and topic hint. Then, the component executes SummarizationService.summarizeText to send a request to the backend to ask Gemini to summarize the web page. SummarizeResultsComponent is responsible for rendering the summary in a list. SummarizeBulletPointComponent also uses viewchild to access the submitted URL and topic hint. Then, the component executes SummarizationService.summarizeToBulletPoints to send a request to the ",
    "summary": "Okay, here's a summary of Connie's programming journey, presented in bullet points:\n\n*   Connie is a software architect specializing in web development using Angular, TypeScript, JavaScript, and NestJS, with a keen interest in Generative AI.\n*   To efficiently filter through the numerous daily blog posts on web development and generative AI, she developed a full-stack text summarization application.\n*   The Angular application has two main components: one that provides a paragraph summary of a blog post and another that generates a bullet-point summary.\n*   The application's functionality includes accepting a web page URL and an optional topic hint to improve summary accuracy using Gemini.\n*   The frontend interacts with a NestJS backend to request summaries from Gemini, displaying the results using specific components and a custom pipe for formatting.\n*   Connie containerized the Angular application using Docker, including configurations for ignoring files, setting environment variables, and using Docker Compose to manage the Angular and NestJS containers.\n*   The application can be accessed via a browser, and the project was created to practice Generative AI concepts with plans to apply the knowledge in production.\n*   Connie aims to share her ongoing learning experiences in Angular, NestJS, Generative AI, and other technologies.",
    "url": "https://www.blueskyconnie.com/built-text-summarization-application-to-summarize-web-page-with-angular/",
    "style": "bullet",
    "createdAt": "2025-10-14T13:58:07.919Z"
  },
  {
    "id": "19efe0f8-54ce-4927-9745-a0e2fd6f6e65",
    "text": "Like it or not, we live in the age of AI, and it can be both exciting and frustrating. On one hand, AI can help us unlock almost unlimited capabilities for the apps we build; if in the past, tasks like image recognition or text classification could be a dealbreaker for the average developer, today, customers almost assume one would be able to pull things like this off in ridiculously short timeframes. On the other hand, however, the landscape of AI development is probably best described as \"hostile\". We move at incredible speeds, new models and approaches drop and then die out before we even have time to properly use them, lots of tutorials are actually disguised ways of selling us something, and lots of information is still being gatekeeped by more seasoned developers, hidden behind buzzwords like \"agentic AI\" , \"RAG\" and so on. This can be particularly harsh if you're a JavaScript developer, especially working on frontend, like me, with Angular. \"Do I need to learn Python to do AI?\", \"I'm not a backend developer, how can I build apps with AI?\", and \"How do I even get started, there's so much stuff out there!\" are all questions I've heard from developers in my community. Well, to be honest, those are questions I've asked myself as well. So, for the past couple of months I've been working with the Gemini API, building different apps and tools, and now is the time I dispel some myths for other Angular developers and help them begin their AI journey too. So, hereby, we begin a series of articles on how to build AI-powered apps with Angular and Gemini. This is going to be a ground-up tutorial, broken down into atomic topics that will help you get started without issue. The good news is, no prior knowledge is assumed! If you are an Angular developer who has no idea how people build apps on top of AI models, this is where you start! In this series, we will cover the following topics: Please do not assume this is going to be just a 7 article series, it is very possible I ",
    "summary": "This article introduces a series on building AI-powered Angular apps using the Gemini API, targeted at Angular developers with no prior AI experience. It covers setting up the Gemini API with a secure backend using Express.js to protect the API key. It also explores how to use the Gemini API in Angular and how to modify the LLM responses, like setting the temperature or the max output tokens.",
    "url": "https://www.angularspace.com/building-ai-powered-apps-with-angular-and-gemini/",
    "style": "short",
    "createdAt": "2025-10-14T14:52:15.429Z"
  },
  {
    "id": "cc18038c-aa2f-449d-a3aa-19b30c4443c9",
    "text": "Hello",
    "summary": "Okay, I'm ready! What style of summary would you like for the content \"Hello\"?\n\nSince the content is just \"Hello,\" here are a few options:\n\n*   **Short:** The content is a simple greeting. It expresses \"Hello.\"\n*   **Casual:** The content's just saying hi!",
    "url": "",
    "style": "short",
    "createdAt": "2025-10-14T16:38:43.840Z"
  },
  {
    "id": "f0a7f271-4a03-47a0-a4c0-5655c5d289e0",
    "text": "\n            A space to discuss and keep up software development and manage your software career\n           \n            An inclusive community for gaming enthusiasts\n           \n            News and discussion of science and technology such as AI, VR, cryptocurrency, quantum computing, and more.\n           \n            From composing and gigging to gear, hot music takes, and everything in between.\n           \n            Discussing AI software development, and showing off what we're building.\n           \n            Movie and TV enthusiasm, criticism and everything in-between.\n           \n            A general discussion space for the Forem community. If it doesn't have a home elsewhere, it belongs here\n           \n            Memes and software development shitposting\n           \n            Web design, graphic design and everything in-between\n           \n            A community of golfers and golfing enthusiasts\n           \n            A community for makers, hobbyists, and professionals to discuss Arduino, Raspberry Pi, 3D printing, and much more.\n           \n            Your central hub for all things security. From ethical hacking and CTFs to GRC and career development, for beginners and pros alike\n           \n            For engineers building software at scale. We discuss architecture, cloud-native, and SRE—the hard-won lessons you can't just Google\n           \n            Discussing the core forem open source software project — features, bugs, performance, self-hosting.\n           \n            A collaborative community for all things Crypto—from Bitcoin to protocol development and DeFi to NFTs and market analysis.\n           \n                        Posted on Sep 24, 2024\n\n                        • Edited on Jul 1\n\n                     In this blog post, I describe how to build a customer reply application locally using MediaPipe and Chrome’s Built-In Prompt API.  The application does not need a server and does not use any vendor’s LLM; therefore, the cost ",
    "summary": "This content encompasses a variety of online communities and a blog post. The communities cater to diverse interests including software development and career management, gaming, science and technology discussions (AI, VR, cryptocurrency, quantum computing), music, AI software development showcases, movie and TV enthusiasm, general Forem community discussions, software development memes, web and graphic design, golf, maker projects (Arduino, Raspberry Pi, 3D printing), cybersecurity (ethical hacking, CTFs, GRC, career development), software engineering at scale (architecture, cloud-native, SRE), Forem open-source software project discussions, and cryptocurrency and blockchain technology.\n   The blog post details how to build a local customer reply application using MediaPipe and Chrome's Built-In Prompt API, eliminating the need for a server or vendor LLM. It describes using MediaPipe for sentiment analysis and language detection, then leveraging Chrome's Prompt API to generate responses. The post includes steps for setting up the application, including updating Chrome, installing necessary packages (@mediapipe/tasks-text, iso-639-language), downloading models, configuring CORS policy, initializing models during application startup, and using the APP_INITIALIZER token. It explains how the application uses the models to classify text and detect language, and how the AI Assistant generates replies. The post concludes that software engineers can create Web AI applications without a backend server or cloud LLM costs and are useful for storing commonly asked questions or snippets of code.\n   The summary also recognizes DEV Diamond Sponsors: Google AI, Neon and Algolia. DEV is a space to discuss and keep up with software development and career management and built on Forem open source software and a space for coders to share, stay up-to-date and grow their careers.",
    "url": "https://dev.to/railsstudent/build-a-customer-response-application-with-mediapipe-chromes-built-in-prompt-api-locally-39lj",
    "style": "detailed",
    "createdAt": "2025-10-14T17:25:30.814Z"
  },
  {
    "id": "5ecef558-f5e5-41f4-af6d-8e2448f9c3ef",
    "text": "Build a customer response application with MediaPipe, Chrome's Built-In Prompt API Locally\n#\nangular\n#\ngenai\n#\ntutorial\n#\nwebdev\nChrome AI (6 Part Series)\n1\nBuild a customer response application with MediaPipe, Chrome's Built-In Prompt API Locally\n2\nBuild a translation app with Chrome's Built-in Translation API in Angular\n...\n2 more parts...\n5\nUse Chrome's Prompt API to generate a trip planner in Angular\n6\nConfigure temperature and topK in Chrome's Prompt API\nIn this blog post, I describe how to build a customer reply application locally using MediaPipe and Chrome’s Built-In Prompt API. The application does not need a server and does not use any vendor’s LLM; therefore, the cost is zero. When a user enters feedback, the Text classification task of the MediaPipe SDK identifies the sentiment of the text (positive, negative). Moreover, the language detector task returns the language's ISO 639-1 code. Then, I formulate a prompt and ask Chrome’s Built-In Prompt API to generate a response according to the sentiment, language, and feedback.\n\nUpdate the Chrome Browser\nUpdate the Chrome Browser to the latest version. As of this writing, the newest version of Chrome is 129.\n\nPlease follow the steps in this blog post to download Gemini Nano in Chrome.\n\nhttps://impsbl.hatenablog.jp/entry/CallGeminiNanoLocallyInChrome_en\n\nAngular Application\nScaffold an Angular Application\nng new ng-ai-sprint-customer-response-demo\nInstall dependencies\nnpm i -save-exact @mediapipe/tasks-text iso-639-language\nThe @mediapipe/tasks-text installs the Text Classification and Language Detector tasks packages. The iso-639-language package returns the language name from the ISO 639-1 code.\n\nUpload models to Google Cloud Storage\nFirst, I downloaded the text classifier and language detector models here: and .\n\nThen, I uploaded them to a new GCS bucket to keep my project's bundle size small. Next, I updated the bucket's CORS policy so the Angular application could load these files.\n\n// cors.json\n\n[\n    {\n ",
    "summary": "Here's a short summary of the content:\n\nThis tutorial explains how to build a local customer response application using MediaPipe for sentiment analysis and language detection, along with Chrome's built-in Prompt API for generating responses. The application, built with Angular, leverages MediaPipe's text classification and language detection to understand customer feedback and then uses Chrome's local LLM to generate appropriate replies, eliminating the need for a server or vendor LLM.",
    "url": "",
    "style": "short",
    "createdAt": "2025-10-14T18:06:24.190Z"
  }
]